#!/usr/bin/perl -w
# $Id: archive_check,v 1.10 2007/09/26 19:40:41 pchines Exp $

use strict;
use warnings;
use Getopt::Long;
use Pod::Usage;
use File::Find;
use File::Spec;
our %Opt;
our %Stats;
our %User;      # map UIDs to usernames
our %Group;     # map GIDs to group names
our $AbsDir;    # top-level directory
our $SymLinkFh; # file for symlink output
our $DirPermFh; # file for directory permissions
our $InfoFh;    # file for other output (summary)
our $DetailFh;  # file for file details (database)

our $EMPTY = q{};
our $RECENT = 60 * 60 * 24 * 30;    # one month
our $Gzip = 'gzip';
our $GzipIn;
our $GzipOut;

=head1 NAME

archive_check - check directories to be archived

=head1 SYNOPSIS

Test specified directory tree for external symlinks and other issues, prior
to archiving data to tape:

  archive_check [options] DIR

For complete documentation, run C<archive_check -man>

=head1 DESCRIPTION

Check directories to be archived for potential problems, including:

 - external symlinks
 - broken symlinks
 - recently accessed/changed files

Also reports total size and file owners, for planning and confirmation.
Generates a detailed database of all files and directories if a C<--details>
file is specified.

=cut

#------------
# Begin MAIN 
#------------

process_commandline();
if ($Opt{output}) {
    $SymLinkFh = Open("$Opt{output}.link.txt", 'w');
    $DirPermFh = Open("$Opt{output}.dirs.txt", 'w');
    $InfoFh    = Open("$Opt{output}.info.txt", 'w');
}
if ($Opt{details}) {
    $DetailFh  = Open($Opt{details}, 'w');
    print $DetailFh join("\t",
            qw(dir file mode user group size atime mtime)), "\n";
}
for my $dir (@ARGV) {
    # clear data structures
    for my $i (qw(last_atime last_mtime dead_links external_links total_size)) {
        $Stats{$i} = 0;
    }
    %User = ();
    %Group = ();
    # evaluate each directory
    $AbsDir = File::Spec->rel2abs($dir);
    if (!$Opt{output}) {
        my ($v,$p,$d) = File::Spec->splitpath($AbsDir);
        $SymLinkFh = Open("$d.link.txt", 'w');
        $DirPermFh = Open("$d.dirs.txt", 'w');
        $InfoFh    = Open("$d.info.txt", 'w');
    }
    find(\&check, $AbsDir);
    report_info();
}
warn "Grand total: ", human_readable($Stats{"grand_total"}), "\n";
for my $w (sort keys %{ $Stats{"warnings"} }) {
    warn "$w\n";
}

#------------
# End MAIN
#------------

# receives $_ (filename), chdir-ed to enclosing dir
# $File::Find::dir  is path
# $File::Find::name is full path to file
sub check {
    for my $ex (@{ $Opt{exclude} }) {
        if ($File::Find::name =~ /^$ex/) {
            $File::Find::prune = 1;
            return;
        }
    }
    if (-l) {
        if (-e) {
            my $loc = readlink;
            # check whether link is internal or external
            my $absloc = File::Spec->rel2abs($loc);
            my $pre = $Opt{ignore};
            if ($absloc !~ /^(\Q$pre\E)?\Q$AbsDir\E/) {
                print $SymLinkFh join("\t", "external", $File::Find::name,
                        $loc, $absloc), "\n";
                # consider reporting size of external linked files
                # not sure what to do about dirs; total size of contents?
                ++$Stats{"external_links"};
            }
        }
        else {
            print $SymLinkFh "dead\t", $File::Find::name, "\n";
            ++$Stats{"dead_links"};
        }
        if ($DetailFh) {
            my @s = lstat;
            print $DetailFh join("\t", $File::Find::dir, $_,
                    sprintf("%06o", $s[2]), $User{$s[4]},
                    $Group{$s[5]}, $s[7], iso_datetime($s[8]),
                    iso_datetime($s[9])), "\n";
        }
        return;
    }
    my @s = stat;
    record_user_and_group(@s[4,5]);
    if (-d _) {
        # record permissions for directory, so can be reconstituted
        print $DirPermFh join("\t", $File::Find::name, sprintf("%04o", $s[2] & 07777),
                $User{$s[4]}, $Group{$s[5]}, @s[8,9]), "\n";
    }
    else {
        if ($DetailFh) {
            print $DetailFh join("\t", $File::Find::dir, $_,
                    sprintf("%06o", $s[2]), $User{$s[4]},
                    $Group{$s[5]}, $s[7], iso_datetime($s[8]),
                    iso_datetime($s[9])), "\n";
        }
        $Stats{"total_size"} += $s[7];
        # check last accessed/changed date
        if ($Stats{"last_atime"} < $s[8]) {
            $Stats{"last_atime"} = $s[8];
        }
        if ($Stats{"last_mtime"} < $s[9]) {
            $Stats{"last_mtime"} = $s[9];
        }
    }
}

sub iso_datetime {
    my ($e) = @_;
    my @t = $Opt{utc} ? gmtime($e) : localtime($e);
    return sprintf("%d-%02d-%02dT%02d:%02d:%02d", $t[5]+1900, $t[4]+1, $t[3],
            $t[2], $t[1], $t[0]);
}

sub record_user_and_group {
    my ($uid, $gid) = @_;
    if (!exists $User{$uid}) {
        ($User{$uid}) = getpwuid($uid);
        if (!defined $User{$uid}) {
            $User{$uid} = $uid;
        }
    }
    if (!exists $Group{$gid}) {
        ($Group{$gid}) = getgrgid($gid);
        if (!defined $Group{$gid}) {
            $Group{$gid} = $gid;
        }
    }
}

sub human_readable {
    my ($val, $fmt) = @_;
    $fmt ||= "%.2f";
    my $suffix = $EMPTY;
    if ($val > 1024) {
        $val /= 1024;
        $suffix = "K";
    }
    if ($val > 1024) {
        $val /= 1024;
        $suffix = "M";
    }
    if ($val > 1024) {
        $val /= 1024;
        $suffix = "G";
    }
    if ($val > 1024) {
        $val /= 1024;
        $suffix = "T";
    }
    return sprintf "$fmt\%s", $val, $suffix;
}

sub report_info {
    $Stats{"grand_total"} += $Stats{"total_size"};
    my $size = human_readable($Stats{"total_size"});
    my $atime = localtime($Stats{"last_atime"});
    my $mtime = localtime($Stats{"last_mtime"});
    print $InfoFh <<"END_SUMMARY";
Pre-archive report for $AbsDir
\tTotal size of files:\t$size
\tLatest access time:\t$atime
\tLatest modify time:\t$mtime
\tNumber of dead links:\t$Stats{"dead_links"}
\tNo. of external links:\t$Stats{"external_links"}

END_SUMMARY
    print $InfoFh "Users who own files/directories in this tree:\n";
    for my $u (sort values %User) {
        print $InfoFh "\t$u\n";
    }
    print $InfoFh "Groups who can access files/directories in this tree:\n";
    for my $g (sort values %Group) {
        print $InfoFh "\t$g\n";
    }
    if ($Stats{"dead_links"}) {
        $Stats{"warnings"}{"Dead symlinks were found"} = 1;
    }
    if ($Stats{"external_links"}) {
        $Stats{"warnings"}{"Symlinks to external files were found"} = 1;
    }
    my $time = time;
    if ($time - $Stats{"last_atime"} < $RECENT) {
        $Stats{"warnings"}{"Some files have been accessed recently"} = 1;
    }
    if ($time - $Stats{"last_mtime"} < $RECENT) {
        $Stats{"warnings"}{"Some files have been modified recently"} = 1;
    }
}

# cut and pasted from GTB::File, to avoid having non-core dependencies
# then: s/croak/die/ (all of the "or die" were originally die, others croak)
sub Open {
    my ($file, $mode) = @_;
    if (!$file && $file ne '0') {
        die "Open: no filename provided";
    }
    if ($mode) {
        $mode = lc $mode;
    }
    elsif ($file =~ /^\s*\|/) {
        $mode = 'w';
    }
    else {
        $mode = 'r';
    }
    my $fh;
    if ($file =~ /\|/) {
        if ($mode eq 'r') {
            if ($file =~ /\|\s*$/) {
                open $fh, $file or die "Can't open pipe '$file', $!\n";
            }
            else {
                die "To open pipe for reading, pipe character must "
                    . "appear at end of command";
            }
        }
        elsif ($mode eq 'w') {
            if ($file =~ /^\s*\|/) {
                open $fh, $file or die "Can't open pipe '$file', $!\n";
            }
            else {
                die "To open pipe for writing, pipe character must "
                    . "appear at beginning of command";
            }
        }
        else { # pipe, but not first or last in sequence
            die << "END_MSG";
If a pipe character is present in the open string, there must be a pipe at
the beginning or end of the string, depending upon whether you plan to
write or read to the filehandle; '$file' is not valid.  If you need to read
and write to a program, try IPC::Open2 or IPC::Open3.
END_MSG
        }
    }
    elsif ($file =~ /\.(b?gz|bz2|zip|Z)$/) {
        if ($mode eq 'r') {
            my $prog = $1 eq 'bz2' ? 'bzip2' : ($GzipIn || $Gzip);
            die "File ($file) not found" unless (-e $file);
            die "File ($file) was not readable" unless (-r $file);
            open $fh, "$prog -dc $file |"
                or die "Can't read $file with $prog, $!\n";
        }
        elsif ($mode eq 'w') {
            my $prog = $1 eq 'bz2' ? 'bzip2' : ($GzipOut || $Gzip);
            open $fh, "| $prog > $file"
                or die "Can't create $prog file $file, $!\n";
        }
        elsif ($mode eq 'a') {
            if ($1 eq 'bz2') {
                die "Open: mode 'a' not supported for bzip2 file $file";
            }
            my $prog = $GzipOut || $Gzip;
            open $fh, "| $prog >> $file"
                or die "Can't append $prog output to $file, $!\n";
        }
        else {
            die "Open: mode '$mode' not supported; use 'r', 'w' or 'a'";
        }
    }
    elsif ($file eq '-') {
        if ($mode eq 'r') {
            open $fh, '-' or die "Can't read from STDIN, $!\n";
        }
        elsif ($mode eq 'w' || $mode eq 'a') {
            open $fh, '>-' or die "Can't write to STDOUT, $!\n";
        }
        else {
            die "Open: mode '$mode' not supported; use 'r', 'w' or 'a'";
        }
    }
    elsif ($mode eq 'r') {
        open $fh, '<', $file or die "Can't open $file, $!\n";
    }
    elsif ($mode eq 'w') {
        open $fh, '>', $file or die "Can't create $file, $!\n";
    }
    elsif ($mode eq 'a') {
        open $fh, '>>', $file or die "Can't append to $file, $!\n";
    }
    else {
        die "Open: mode '$mode' not supported; use 'r', 'w' or 'a'";
    }
    return $fh;
}

sub process_commandline {
    # Set defaults here
    %Opt = (exclude => [],
            ignore  => $EMPTY);
    GetOptions(\%Opt, qw(details=s exclude=s ignore=s output=s utc
                manual help+ version)) || pod2usage(0);
    if ($Opt{manual})  { pod2usage(verbose => 2); }
    if ($Opt{help})    { pod2usage(verbose => $Opt{help}-1); }
    if ($Opt{version}) { die "archive_check, ", q$Revision: 1991 $, "\n"; }
    # If non-option arguments are required, uncomment next line
    if (!@ARGV) {
        pod2usage("Expected directory name(s)");
    }
    my @nd = grep { !-d } @ARGV;
    if (@nd) {
        warn "Argument '$_' is not a directory\n" for @nd;
        #pod2usage("All arguments must be existing directories");
    }
    # Add criteria to test option arguments below
    if ($Opt{ignore}) {
        # end without slash
        $Opt{ignore} =~ s{/*$}{};
    }
}

__END__

=head1 OPTIONS

=over 4

=item B<--details> FILE

If a details file is provided, file directory, name, size, permissions and
access/modify times will be written for each file.  Times will be in local
timezone unless C<--utc> option is used.

=item B<--exclude> DIR

Exclude the given subdirectory.  This option can be used multiple times.

=item B<--output> PREFIX

Prefix for output files.  Defaults to basename of each directory provided.

=item B<--utc>

Write time stamps in universal (GMT, aka UTC) time, rather than local
timezone.

=item B<--help|--manual>

Display documentation.  One C<--help> gives a brief synopsis, C<-h -h> shows
all options, C<--manual> provides complete documentation.

=back

=head1 AUTHOR

 Peter Chines - pchines@mail.nih.gov

=head1 LEGAL

This software/database is "United States Government Work" under the terms of
the United States Copyright Act.  It was written as part of the authors'
official duties for the United States Government and thus cannot be
copyrighted.  This software/database is freely available to the public for
use without a copyright notice.  Restrictions cannot be placed on its present
or future use. 

Although all reasonable efforts have been taken to ensure the accuracy and
reliability of the software and data, the National Human Genome Research
Institute (NHGRI) and the U.S. Government does not and cannot warrant the
performance or results that may be obtained by using this software or data.
NHGRI and the U.S.  Government disclaims all warranties as to performance,
merchantability or fitness for any particular purpose. 

In any work or product derived from this material, proper attribution of the
authors as the source of the software or data should be made, using "NHGRI
Genome Technology Branch" as the citation. 

=cut
