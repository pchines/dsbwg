#!/usr/bin/perl -w
use strict;
use warnings;
use Getopt::Long;
use Pod::Usage;
use GTB::File qw(Open);
use GTB::Run qw(as_number);
use GTB::File::Iter;

our %Opt;
our $EMPTY = q{};
our $COMMA = q{,};
# NIH ActiveDirectory prefix
our $NIH_PREFIX = "S-1-5-21-12604286-656692736-1848903544";

=head1 NAME

isilon_summarize_report - gather disk usage info from csv reports

=head1 SYNOPSIS

Gather per-user disk usage, report:

  isilon_summarize_report server.usr.quota.csv

For complete documentation, run C<isilon_summarize_report -man>

=head1 DESCRIPTION

Gather per-user disk usage, report total space used.

=cut

process_commandline();
my $rh_mnt  = read_isilon_mounts();
my $rh_host = {};
my %user_dir;
my %serv_hosts;
for my $file (@ARGV) {
    my $date = $file =~ /(\d{8})/ ? $1 : $EMPTY;
    my $serv = $file =~ /(\w+)\.usr\.quota/ ? $1 : "unknown";
    my $iter = GTB::File::Iter->new(file => $file, fs => $COMMA);
    while (my $rh = $iter->next_hash) {
        $serv_hosts{$serv}{$rh->{Path}}
            ||= which_hosts($rh_mnt, $serv, $rh->{Path});
        add_user_dir($rh, \%user_dir, $serv, $rh_host,
                $serv_hosts{$serv}{$rh->{Path}});
    }
    warn_missing_exports($rh_mnt, $serv);
}
report_totals(\%user_dir, $Opt{path});

sub report_totals {
    my ($rh_ud, $path) = @_;
    my $ofh = Open($Opt{output}, 'w');
    my $total = 0;
    my $unk = 0;
    my %user;
    for my $u (keys %$rh_ud) {
        my $rh_u = $rh_ud->{$u};
        my @dirs = sort grep { !/^__/ } keys %$rh_u;
        while (@dirs) {
            my $d = shift @dirs;
            my $used = $rh_u->{$d};
            if (defined $used) {
                $user{$u} += $used;
                if ($Opt{details}) {
                    print $ofh join($COMMA, $u, $d,
                            sprintf($Opt{numeric}, $used)), "\n";
                }
                else {
                    # have total, so exclude subdirs
                    @dirs = grep { !/^$d/ } @dirs
                }
            }
        }
        print $ofh join($COMMA, $u, "TOTAL",
                sprintf($Opt{numeric}, $user{$u})), "\n";
        if ($u =~ /^(UID|SID|NIH):/) {
            $unk += $user{$u};
        }
        $total += $user{$u};
    }
    # report totals
    print $ofh join($COMMA, "Unknown", $EMPTY,
            sprintf($Opt{numeric}, $unk)), "\n";
    print $ofh join($COMMA, "TOTAL", $EMPTY,
            sprintf($Opt{numeric}, $total)), "\n";
}

sub add_user_dir {
    my ($rh, $rh_ud, $isilon, $rh_uid, $ra_hosts) = @_;
    if ($rh->{Type} ne 'user') {
        return;
    }
    my $user =$rh->{AppliesTo};
    if ($rh->{AppliesTo} =~ /^UID:(\d+)/) {
        my $uid = $1;
        my $uname;
        my $horig;
        for my $h (@$ra_hosts) {
            $rh_uid->{$h} ||= read_passwd_file($h);
            if ($rh_uid->{$h}{$uid}) {
                if ($uname && $uname !~ /\b\Q$rh_uid->{$h}{$uid}\E\b/) {
                    warn "Warning: user ID $uid on $isilon:$rh->{Path}"
                        . " maps to muliple names:"
                        . " $uname($horig) and $rh_uid->{$h}{$uid}($h)\n";
                    $uname .= "/$rh_uid->{$h}{$uid}";
                }
                else {
                    $uname ||= $rh_uid->{$h}{$uid};
                    $horig ||= $h;
                }
            }
        }
        if ($uname) {
            $user = $uname;
        }
    }
    elsif ($rh->{AppliesTo} =~ /^SID:$NIH_PREFIX-(\d+)$/) {
        $user = "NIH:$1";
    }
    if ($rh_ud->{$user}{__ID__}
            && $rh_ud->{$user}{__ID__} ne $rh->{AppliesTo}) {
        warn "Notice: user $user IDs conflict: $rh->{AppliesTo}"
            . " and $rh_ud->{$user}{__ID__}\n";
    }
    else {
        $rh_ud->{$user}{__ID__} = $rh->{AppliesTo};
    }
    my $rh_u = $rh_ud->{$user};
    my @dirs = grep { $_ } File::Spec->splitdir($rh->{Path});
    my $used = as_number($rh->{Used});
    my $path = "$isilon:";
    for my $d (@dirs) {
        $path .= "/$d";
        if ($rh_u->{$path}) {
            if ($rh_u->{$path} < $used) {
                warn sprintf("Notice: using larger estimate"
                        . " $Opt{numeric} -> $Opt{numeric} ( +%.1f%% )"
                        . " for %s on %s\n",
                        $rh_u->{$path}, $used,
                        100*($used - $rh_u->{$path})/$rh_u->{$path},
                        $user, $path);
                $rh_u->{$path} = $used;
            }
        }
    }
    $rh_u->{$path} = $used;
}

sub read_isilon_mounts {
    my %mount;
    my $iter = GTB::File::Iter->new(file => $Opt{mounts});
    while (my $rh = $iter->next_hash) {
        $mount{$rh->{isilon}}{$rh->{isilon_export}}{$rh->{hostname}} = undef;
    }
    return \%mount;
}

sub warn_missing_exports {
    my ($rh_mnt, $serv) = @_;
    for my $exp (sort keys %{ $rh_mnt->{$serv} }) {
        my ($m) = values %{ $rh_mnt->{$serv}{$exp} };
        if (!$m) {
            warn "Warning: no quotas found for export $serv:$exp\n";
        }
    }
}

sub which_hosts {
    my ($rh_mnt, $serv, $path) = @_;
    my %hosts;
    for my $exp (reverse sort keys %{ $rh_mnt->{$serv} }) {
        if ($exp =~ /^$path/) {
            for my $h (keys %{ $rh_mnt->{$serv}{$exp} }) {
                ++$rh_mnt->{$serv}{$exp}{$h};
                $hosts{$h} = undef;
            }
        }
    }
    my @hosts = sort keys %hosts;
    if (!@hosts) {
        warn "Warning: No hosts found connecting to $serv:$path or subdirs\n";
    }
    return \@hosts;
}

sub read_passwd_file {
    my ($host) = @_;
    my $f;
    for my $pat ("$Opt{passwd_dir}/passwd_%s") {
        if (-f sprintf($pat, $host)) {
            $f = sprintf($pat, $host);
            last;
        }
    }
    if (!$f) {
        warn "Warning: did not find passwd file for $host\n";
        return {};
    }
    my %user;
    my $fh = Open($f);
    while (<$fh>) {
        chomp;
        my @f = split /:/;
        $user{$f[2]} = $f[$Opt{column}];
    }
    return \%user;
}

sub process_commandline {
    %Opt = (column      => 0,
            mounts      => "isilon_mounts.txt",
            numeric     => "%.3e",
            output      => "-",
            passwd_dir  => "passwd_files",
            );
    GetOptions(\%Opt, qw(details 
                mounts=s numeric=s output=s passwd_dir=s total=s
                manual help+ version)) || pod2usage(1);
    if ($Opt{manual})  { pod2usage(verbose => 2); }
    if ($Opt{help})    { pod2usage(verbose => $Opt{help}-1); }
    if ($Opt{version}) { die "isilon_summarize_report, ", q$Revision: 1991 $, "\n"; }
}

=head1 OPTIONS

=over 4

=item B<--column> N

Which column of password file to report; defaults to 0 (username); set to 4
for comment (full name).  This option will likely change to something easier
to remember in the near future.

=item B<--mounts> isilon_mounts.txt

Tab-delimited file describing mounts of isilon resources.  Important columns
are: 'hostname', 'isilon', 'isilon_export'.

=item B<--passwd_dir> passwd_files/

Directory where host password files are kept.

=item B<--help|--manual>

Display documentation.  One C<--help> gives a brief synopsis, C<-h -h> shows
all options, C<--manual> provides complete documentation.

=back

=head1 AUTHOR

 Peter Chines - pchines@mail.nih.gov

=head1 LEGAL

This software/database is "United States Government Work" under the terms of
the United States Copyright Act.  It was written as part of the authors'
official duties for the United States Government and thus cannot be
copyrighted.  This software/database is freely available to the public for
use without a copyright notice.  Restrictions cannot be placed on its present
or future use.

Although all reasonable efforts have been taken to ensure the accuracy and
reliability of the software and data, the National Human Genome Research
Institute (NHGRI) and the U.S. Government does not and cannot warrant the
performance or results that may be obtained by using this software or data.
NHGRI and the U.S.  Government disclaims all warranties as to performance,
merchantability or fitness for any particular purpose.

In any work or product derived from this material, proper attribution of the
authors as the source of the software or data should be made, using "NHGRI
Genome Technology Branch" as the citation.

=cut
